# CPPstudy

1. **Creational Patterns**  
Creational patterns in C++ focus on flexible object creation while minimizing coupling between classes and their implementations.

2. **Singleton**  
Ensures a class has only one instance, using private constructors and static members for global access.

3. **Factory Method**  
Defines an interface for object creation, delegating type determination to subclasses using inheritance and polymorphism.

4. **Abstract Factory**  
Creates families of related objects without specifying concrete classes, leveraging abstract classes and templates in C++.

5. **Builder**  
Separates complex object construction from representation, enabling fluent APIs for creating diverse configurations.

6. **Prototype**  
Generates new objects by cloning existing ones using copy constructors and deep-copy mechanisms.

7. **Structural Patterns**  
Structural patterns emphasize class and object composition, facilitating modular, scalable, and extensible C++ systems.

8. **Adapter**  
Converts one interface into another using multiple inheritance or operator overloading to integrate legacy code seamlessly.

9. **Bridge**  
Decouples abstraction from implementation using pointers and virtual functions for independent variation.

10. **Composite**  
Represents part-whole hierarchies with recursive structures and polymorphism, ideal for file systems or graphical elements.

11. **Decorator**  
Dynamically adds behavior to objects without altering their structure, leveraging composition and operator overloading.

12. **Facade**  
Provides a unified interface to encapsulate complex subsystems into a single, simplified class.

13. **Flyweight**  
Minimizes memory usage by sharing data between similar objects through object pooling and explicit memory control.

14. **Proxy**  
Acts as a surrogate for another object, enabling lazy initialization, access control, or remote procedure calls.

15. **Behavioral Patterns**  
Behavioral patterns facilitate object interactions and workflows, promoting dynamic communication and responsibility management.

16. **Chain of Responsibility**  
Passes requests along a chain of handlers, implemented via function pointers or object references.

17. **Command**  
Encapsulates requests as objects, enabling parameterization, queuing, and undo/redo functionality using callable objects.

18. **Interpreter**  
Defines and evaluates grammars or expressions, suitable for scripting engines or mathematical computations.

19. **Iterator**  
Provides a uniform way to traverse collections without exposing their internal structure, exemplified by STL iterators.

20. **Mediator**  
Centralizes communication between objects, reducing dependencies, often implemented in GUI frameworks with observer patterns.

21. **Memento**  
Captures and restores an object's state using serialization libraries or copy constructors.

22. **Observer**  
Establishes one-to-many relationships, notifying dependents of changes using event-based systems or signals/slots.

23. **State**  
Changes an object's behavior dynamically based on its internal state using polymorphism or function pointers.

24. **Strategy**  
Encapsulates interchangeable algorithms, implemented efficiently with templates and function objects for diverse use cases.

25. **Template Method**  
Defines an algorithmâ€™s skeleton in base classes, deferring specific steps to subclasses via inheritance and virtual functions.

26. **Visitor**  
Encapsulates operations for object structures using double-dispatch, suitable for tasks like syntax tree traversal.
